= sh, mash: Window frames for the Inferno shells


*wm/sh* [ *-w* _width_ ] [ *-h* _height_ ] [ *-f* _font_ ] _sh-args_ +
*wm/mash* _mash-args_ +


Both *wm/sh* and *wm/mash* provide a graphical framework to their
respective shells. Both wrappers manage the input and output of the
shell. They provide facilities for scrolling and editing the output
buffer and for constructing input to be sent to the shell.

*Wm/sh* invokes the shell _sh_(1) with the arguments *-n* _sh-args_;
*wm/mash* invokes _mash_(1) with the arguments _mash-args_. *Wm/sh*
accepts the following additional options, which are not passed through
to _sh_:

*-w* _width_ +
The window should be at least _width_ pixels wide.

*-h* _height_ +
The window should be at least _height_ pixels high.

*-f* _font_ +
Specify the font to use in the window. _Font_ should be the name of a
valid _font_(6) file.

*Wm/sh* and *wm/mash* both provide their own versions of */dev/cons* and
*/dev/consctl* files in the namespace of the invoked shell (see
_cons_(3) for the originals) and attach the standard input of the
invoked shell to the virtualised */dev/cons* file. Output from the
shell, or of any commands run by the shell, is displayed in a scrollable
text window, appearing at the _output position_, which is at the end of
any previously output text, before any as-yet-unread user input text.

Any text displayed on the console can be edited. Typed text is always
inserted at the position of the input cursor. The input cursor can be
moved to any point in the text by clicking mouse button-1 at the desired
position. Selections can be made by dragging the mouse with button-1
held down. Typing into a selection copies its text to the Snarf buffer,
the selected text is deleted and the typed character inserted.

Text typed beyond the output point will be made available to commands
reading from */dev/cons*. Normally this text is made available when
newline is typed, but typing ESC turns on _hold_ mode (the text turns
blue), deferring the availability of the text until ESC is typed again,
turning hold mode off. This allows simple multi-line editing of the
standard input to a command.

Writing *rawon* to */dev/consctl* changes the above behaviour, making
each character typed beyond the output point available to commands as
soon as it is typed; the character is not automatically echoed. Writing
*rawoff* to */dev/consctl* reverses this behaviour.

In addition to dragging out selections, they can be made by double
clicking mouse button-1. Double clicking over a word selects the whole
word. Double clicking next to a brace or bracket selects the text
between it and its matching brace or bracket. If there is no match then
no selection is made.

Clicking mouse button-2 displays a pop-up menu of editing commands:

*Cut*::
  Copy the current selection to the Snarf buffer and then delete the
  selected text. This command has no effect if there is no selected
  text, the Snarf buffer is not cleared.
*Paste*::
  When there is no text selected, the contents of the Snarf buffer are
  inserted at the current input cursor. If a selection exits, its text
  is replaced by that of the Snarf buffer. The new text is then
  selected. The contents of the Snarf buffer remain unaltered.
*Snarf*::
  Copy the selected text to the Snarf buffer. This command has no effect
  if there is no selected text.
*Send*::
  If there is any text selected it is copied to the Snarf buffer. The
  contents of the Snarf buffer is then appended to the end of the
  current shell input line, forwarding any NewLine completed lines to
  the shell's input stream.

Mouse chording is implemented as in _acme_(1). Dragging a selection with
button-1 held down and then also clicking button-2 cuts the selected
text into the Snarf buffer. Clicking button-3 instead of button-2
replaces the selected text with the contents of the Snarf buffer.

Clicking mouse button-3 plumbs the word or selection under the click
point. See _plumber_(8) for more information on plumbing.

_Wm/sh_ also serves the file */chan/shctl*. The following commands may
be written to this file:

*cwd* _dir_ +
Causes any plumbing request generated by _wm/sh_ to be created with
_dir_ as its ``current directory''. This is shown in the title bar of
the window. Note that it is up to the command running inside _wm/sh_ to
keep this up to date (for instance, see EXAMPLES, below).

*button* _title sendtext_ +
A Tk button is created at the top of the shell window, labeled with
_title_. When activated, _sendtext_ will be sent to the shell window as
if it had been typed.

*action* _title sendtext_ +
A button is created as for the *button* command, except that activation
of the button causes _sendtext_ to be sent to any process reading from
*/chan/shctl*.

*clear* +
Delete any buttons that have been created.

Arguments to commands sent to */chan/shctl* follow _sh_(1) quoting rules
(the same as implemented by _quoted_ and _unquoted_ in _string_(2)). A
process reading from */chan/shctl* will block until an *action* button
is activated, whereupon it will yield the _sendtext_ associated with the
button.

== PLUMBING

Both *wm/sh* and *wm/mash* plumb text selected by button 3; an empty
selection plumbs the white-space bounded text surrounding the selection.

== EXAMPLES

Define a _sh_(1) function to update the current directory automatically:

....
	fn cd {builtin cd $*; echo cwd `{pwd} >/chan/shctl}
....

Note that this will not work in all cases, as it is possible to change
the current directory without using the _cd_ command.

Create a button to automate a _mount_ command (note the newline in the
argument string):

....
	echo ${quote button mount 'mount kremvax /n/remote
	'} > /chan/shctl
....

Create a new _wm/sh_ window with the above button already created:

....
	wm/sh -ic {
		echo ${quote button mount 'mount kremvax /n/remote
	'} > /chan/shctl
	}
....

== SOURCE

*/appl/wm/sh.b* +
*/appl/wm/mash.b* +

== SEE ALSO

_sh_(1), _mash_(1), _wm_(1), _plumber_(8)
