WM-SH(1)               General Commands Manual              WM-SH(1)

NAME
       sh, mash - Window frames for the Inferno shells

SYNOPSIS
       wm/sh [ -w width ] [ -h height ] [ -f font ] sh-args
       wm/mash mash-args

DESCRIPTION
       Both wm/sh and wm/mash provide a graphical framework to their
       respective shells.  Both wrappers manage the input and output
       of  the  shell.   They  provide  facilities for scrolling and
       editing the output buffer and for constructing  input  to  be
       sent to the shell.

       Wm/sh  invokes the shell sh(1) with the arguments -n sh-args;
       wm/mash invokes mash(1) with the arguments mash-args.   Wm/sh
       accepts  the  following  additional  options,  which  are not
       passed through to sh:

       -w width
              The window should be at least width pixels wide.

       -h height
              The window should be at least height pixels high.

       -f font
              Specify the font to use in the window.  Font should be
              the name of a valid font(6) file.

       Wm/sh   and  wm/mash  both  provide  their  own  versions  of
       /dev/cons and /dev/consctl files  in  the  namespace  of  the
       invoked  shell (see cons(3) for the originals) and attach the
       standard input  of  the  invoked  shell  to  the  virtualised
       /dev/cons  file.   Output  from the shell, or of any commands
       run by the shell, is displayed in a scrollable  text  window,
       appearing  at the output position, which is at the end of any
       previously output text, before any as-yet-unread  user  input
       text.

       Any  text displayed on the console can be edited.  Typed text
       is always inserted at the position of the input cursor.   The
       input  cursor can be moved to any point in the text by click‐
       ing mouse button-1 at the desired position.   Selections  can
       be  made by dragging the mouse with button-1 held down.  Typ‐
       ing into a selection copies its text to the Snarf buffer, the
       selected text is deleted and the typed character inserted.

       Text  typed beyond the output point will be made available to
       commands reading from /dev/cons.  Normally this text is  made
       available when newline is typed, but typing ESC turns on hold
       mode (the text turns blue), deferring the availability of the
       text  until  ESC  is typed again, turning hold mode off. This
       allows simple multi-line editing of the standard input  to  a
       command.

       Writing  rawon  to  /dev/consctl changes the above behaviour,
       making each character typed beyond the output point available
       to  commands  as  soon  as  it is typed; the character is not
       automatically echoed. Writing rawoff to /dev/consctl reverses
       this behaviour.

       In  addition  to dragging out selections, they can be made by
       double clicking mouse button-1.  Double clicking over a  word
       selects  the  whole word.  Double clicking next to a brace or
       bracket selects the text between it and its matching brace or
       bracket.  If there is no match then no selection is made.

       Clicking  mouse  button-2  displays  a pop-up menu of editing
       commands:

       Cut    Copy the current selection to  the  Snarf  buffer  and
              then  delete  the  selected text.  This command has no
              effect if there is no selected text, the Snarf  buffer
              is not cleared.

       Paste  When  there  is  no text selected, the contents of the
              Snarf buffer are inserted at the current input cursor.
              If  a selection exits, its text is replaced by that of
              the Snarf buffer.  The new text is then selected.  The
              contents of the Snarf buffer remain unaltered.

       Snarf  Copy the selected text to the Snarf buffer.  This com‐
              mand has no effect if there is no selected text.

       Send   If there is any text selected  it  is  copied  to  the
              Snarf  buffer.   The  contents  of the Snarf buffer is
              then appended to the end of the  current  shell  input
              line,  forwarding  any  NewLine completed lines to the
              shell's input stream.

       Mouse chording is implemented  as  in  acme(1).   Dragging  a
       selection with button-1 held down and then also clicking but‐
       ton-2 cuts the selected text into the Snarf buffer.  Clicking
       button-3  instead of button-2 replaces the selected text with
       the contents of the Snarf buffer.

       Clicking mouse button-3 plumbs the word  or  selection  under
       the  click  point.   See  plumber(8)  for more information on
       plumbing.

       Wm/sh also serves the file /chan/shctl.  The  following  com‐
       mands may be written to this file:

       cwd dir
              Causes  any  plumbing request generated by wm/sh to be
              created with dir as its ``current directory''. This is
              shown in the title bar of the window.  Note that it is
              up to the command running inside wm/sh to keep this up
              to date (for instance, see EXAMPLES, below).

       button title sendtext
              A Tk button is created at the top of the shell window,
              labeled with title.  When activated, sendtext will  be
              sent to the shell window as if it had been typed.

       action title sendtext
              A  button is created as for the button command, except
              that activation of the button causes  sendtext  to  be
              sent to any process reading from /chan/shctl.

       clear
              Delete any buttons that have been created.

       Arguments  to commands sent to /chan/shctl follow sh(1) quot‐
       ing rules (the same as implemented by quoted and unquoted  in
       string(2)).   A  process  reading from /chan/shctl will block
       until an action button is activated, whereupon it will  yield
       the sendtext associated with the button.

PLUMBING
       Both  wm/sh  and  wm/mash plumb text selected by button 3; an
       empty selection plumbs the white-space bounded text surround‐
       ing the selection.

EXAMPLES
       Define a sh(1) function to update the current directory auto‐
       matically:

            fn cd {builtin cd $*; echo cwd `{pwd} >/chan/shctl}

       Note that this will not work in all cases, as it is  possible
       to change the current directory without using the cd command.

       Create a button to automate a mount command (note the newline
       in the argument string):

            echo ${quote button mount 'mount kremvax /n/remote
            '} > /chan/shctl

       Create a new wm/sh window with the above button already  cre‐
       ated:

            wm/sh -ic {
                 echo ${quote button mount 'mount kremvax /n/remote
            '} > /chan/shctl
            }

SOURCE
       /appl/wm/sh.b
       /appl/wm/mash.b

SEE ALSO
       sh(1), mash(1), wm(1), plumber(8)

                                                            WM-SH(1)
