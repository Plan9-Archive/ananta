= collabsrv: multi-user collaboration

== SYNOPSIS

*collab/collabsrv* [ **-f **__keyfile__ ] [ **-n **__netaddress__ ] [
_dir_ ]

*collab/servers/chatsrv*

*collab/servers/mpx*

*collab/servers/wbsrv*


_Collabsrv_ listens on network address _netaddress_ (default:
*tcp!*!9999*) for incoming requests to attach to services it offers. The
services are defined by the contents of directory _dir_ (default:
*/services/collab*). _Collabsrv_ serves an authenticated 9P connection
that exports the contents of __dir__**/export** (default:
*/services/collab/export*). The exported name space can contain
directories from a shared file server, but it will also contain a
directory *services* giving access to any collaborative activity
services that have been configured.

The *services* directory contains a single *ctl* file and a set of
subdirectories, numbered *0*, *1* and so on. The *ctl* is used to
activate and access services. Each service instance is identified by a
name; clients connect to a given instance by presenting its name. Each
directory represents one instance of a service. Each service instance
corresponds to a name space; the clients all share that name space. The
name space is determined by the service.

A client wishing to make use of the services must first _dial_(2) to
connect to _collabsrv,_ and authenticate and mount the resulting 9P
connection. It can do so using the _mount_ command (see _bind_(1)), or
by using _security-auth_(2) and *Sys->mount* (see _sys-bind_(2)).
Normally, this is done by _collab_(1).

A new connection to a particular service is requested by opening the
*ctl* file for reading and writing, writing a service request to it, and
reading back the number of the directory corresponding to the requested
service. A service request written to *ctl* is text of the following
form:

_service id_

where _service_ is a string specifying the type of service (eg, *chat*)
and _id_ is a string identifying the instance. The server does not
interpret _id_; it is up to the clients to agree a naming convention
(often using the name of a shared file as an _id_). _Collabsrv_ will
connect to instance _id_ of the requested _service_ type if one is
already running, or start one if necessary; the write request returns an
error if the service cannot be started. Following a successful write to
*ctl*, a read will return the number of the service directory containing
the client's private connection to that service instance. Closing the
*ctl* file disconnects from the service.

Available services are defined by a configuration file
*/services/collab/services.cfg*, which contains a sequence of
configuration entries of the following form:

....
service


	path=disfile
....

where _service_ is the name presented in a service request, and
_disfile_ names a Dis file implementing that service; path names are
interpreted relative to */services/collab*, but usually refer to files
in */dis/collab/servers*.

Each _collabsrv_ service is represented by a name space peculiar to that
service. The interface to the service is therefore implemented by a
service-specific 9P server (_disfile_ in the configuration file).
Current services are described below.

=== Chat

_Chatsrv_ provides a simple service for the exchange of text messages.
It serves a name space containing two files. The files together
represent a single messaging group:

*users*::
  A read-only file that lists the user names of the current members of
  the group, one per line. The version number of the file's Qid (see
  _sys-stat_(2)) is incremented each time a client arrives or leaves.
*msgs*::
  +
  A client connects to the messaging group by opening this file. A
  message is sent to the group by writing to the file. Each read returns
  the next unread message, prefixed by the name of the sender, or
  *<you>* for a message sent by the current client. A client sees no
  messages sent before it connects. Messages are delivered in the same
  order to all clients; clients receive their own messages. Two special
  messages are generated by the server:
  +
....
+++ name has arrived
--- name has left
....
  +
  as clients come and go.

=== Multiplexor

_Mpx_ offers a general fan-out/fan-in multiplexing service for a tree of
processes, with one controlling or root process at the root of the tree,
and a set of client processes at the leaves of the tree. It serves three
files:

*root*::
  An exclusive-use file read and written by the root process to
  communicate with the leaf processes.
*leaf*::
  Client processes read and write this file to communicate with the root
  process (each *open* of *leaf* is independent). It cannot be opened
  until a process has opened *root*. After *root* has been closed, and
  any remaining messages on *leaf* have been read, subsequent reads will
  return zero bytes (end-of-file).
*users*::
  A read-only text file that lists the user names of processes that
  currently have *leaf* open. There is one line per leaf, containing a
  unique numeric ID for the leaf, a space, and then the users's name.

A message written to *root* is replicated on all instances of *leaf*
that are currently open. A message written to any instance of *leaf*
will be read by the process reading *root*. Data written to both *root*
and *leaf* has a prefix added to identify the sender, causing messages
to have the following format:

....
seq clientid op name data
....

where _seq_ is a unique message sequence number; _clientid_ is a unique
number identifying the process amongst currently connected clients, with
0 identifying the root process; _op_ is a single character giving the
message type (see below); _name_ is the sending process's user name; and
_data_ is the data written by the process, which can be text or binary
(the message header is always text). _Mpx_ also generates messages as
root and leaf processes arrive and leave. These are identified by _op_.
The various _op_ values and the direction in which they can occur are
listed below:

*a*::
  New leaf process has arrived (leaf to root)
*M*::
  Message from root process (root to leaf)
*m*::
  Message from leaf process (leaf to root)
*L*::
  Root process has left (root to leaf)
*l*::
  Leaf process has left (leaf to root)

Messages are only ever sent from the root to all leaves, or from a leaf
to the root, never from leaf to leaf; the root process could of course
rebroadcast a message from a leaf. The multiplexor service is used to
implement a real-time poll (see *poll* and *poller* in
_collab-clients_(1)), but could be used for several other services, such
as auctions.

=== Whiteboard

_Wbsrv_ offers a service for sharing a simple line drawing. It serves
two files:

*wb.bit*::
  A read-only file containing an uncompressed _image_(6) with the
  current state of the drawing.
*strokes*::
  This file is read and written to exchange strokes with other clients.
  A stroke has the following representation:
  +
  ______________________________
  _colour width x0 y0 x1 y1 _...
  ______________________________
  +
  where all values are space-separated decimal numbers: _colour_ is an
  index into the _rgbv_(6) colour map; _width_ is the width of the line
  in pixels, and the sequence of coordinate pairs defines the connected
  line segments to draw. A stroke is transmitted from one client to all
  others by writing a stroke description to the file in a single write.
  Each read returns a description of a stroke made by another client.

A whiteboard client should read the *wb.bit* file to obtain its image,
then read the *strokes* file for instructions to keep it up to date.

== FILES

*/services/collab/export/services*::
  active service directory
*/services/collab/services.cfg*::
  maps service names to modules
*/dis/collab/servers*::
  service implementation modules

== SOURCE

*/appl/collabsrv* +
*/appl/collab/servers* +
*/appl/collab/lib*

== SEE ALSO

_collab_(1), _collab-clients_(1)
